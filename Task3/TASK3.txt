#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <map>
#include <iomanip>
using namespace std;

// Function to convert an integer to a two-character hexadecimal string
string counter(int i) {
    // Calculate the tens and ones places in the hexadecimal representation
    int tens = i / 16;
    int ones = i % 16;

    // Convert the tens place to the corresponding character
    char tensDigit = (tens < 10) ? '0' + tens : 'A' + (tens - 10);

    // Convert the ones place to the corresponding character
    char onesDigit = (ones < 10) ? '0' + ones : 'A' + (ones - 10);

    // Initialize an empty string to store the result
    string Ans = "";

    // Append the character representing the tens place to the result string
    Ans += tensDigit;

    // Append the character representing the ones place to the result string
    Ans += onesDigit;

    // Return the final two-character string representing the hexadecimal representation
    return Ans;
}

// Class representing a simple CPU with registers
class CPU {
private:
    // Private member variable to store the CPU registers
    vector<string> Registers;

public:
    // Constructor initializes the Registers vector with 16 elements, each set to "00"
    CPU() : Registers(16, "00") {}

    // Set the value of a specific register (indexed by 'n') to the provided hexadecimal string 'Hex'
    void setRegister(int n, string Hex) {
        Registers[n] = Hex;
    }

    // Clear the value of a specific register (indexed by 'n') by setting it to "00"
    void Clear(int n) {
        Registers[n] = "00";
    }

    // Retrieve and return the hexadecimal value of a specific register (indexed by 'n')
    string DisplayRegister(int n) {
        return Registers[n];
    }
};

// Class representing a basic memory with read functionality from a file
class Memory {
protected:
public:
    // Public member variable to store memory contents as key-value pairs (address-value)
    map<string, string> memory;

    // Function to read memory contents from a file and populate the memory map
    void ReadFile(string FileName) {
        // Open the file for reading
        fstream MyFile;
        int PC = 0;  // Program Counter for tracking memory addresses

        // Attempt to open the file
        MyFile.open(FileName + ".txt", ios::in);

        if (MyFile.is_open()) {
            string line;

            // Read each line from the file
            while (getline(MyFile, line)) {
                // Generate the hexadecimal address using the counter function
                string Address = counter(PC);

                // Insert the first two characters of the line into memory at the generated address
                memory.insert({Address, line.substr(0, 2)});

                // Move to the next address
                PC++;

                // Generate the next hexadecimal address
                Address = counter(PC);

                // Insert the next two characters of the line into memory at the generated address
                memory.insert({Address, line.substr(2, 2)});

                // Move to the next address
                PC++;
            }
        } else {
            // Display an error message if the file cannot be opened
            cout << "Error opening file: " << FileName << ".txt" << '\n';
        }

        // Close the file after reading
        MyFile.close();
    }

    // Function to clear all elements from the memory map
    void Clear() {
        memory.clear(); // Clears all elements from the map
    }

    // Function to retrieve a constant reference to the memory map
    const map<string, string>& getMemoryMap() const {
        return memory;
    }
};

// Class representing the main machine, inheriting from the Memory class
class machine : public Memory {
private:
    Memory Storage;  // Instance of Memory for additional storage
    CPU Registers;   // Instance of CPU for managing registers
    int PC = 0;       // Program Counter to track the execution of instructions

public:
    friend void Menu();  // Friend function declaration for the Menu function

    // Constructor to initialize the machine by reading instructions from a file
    machine(string FileName) {
        ReadFile(FileName);
    }

    // Run the machine until termination, executing instructions
    void RunFull() {
        while (PC != -1) {
            if (PC == -1) {
                return;
            }
            string hxPC = counter(PC);
            if (memory[hxPC][0] == '1') {
                string pattern = memory[counter(PC + 1)];
                LoadRegisterFromMemory(memory[hxPC][1] - '0', pattern);
            } else if (memory[hxPC][0] == '2') {
                string pattern = memory[counter(PC + 1)];
                LoadRegisterWithPattern(memory[hxPC][1] - '0', pattern);
            } else if (memory[hxPC][0] == '3') {
                string pattern = memory[counter(PC + 1)];
                StoreRegisterToMemory(memory[hxPC][1] - '0', pattern);
            } else if (memory[hxPC][0] == '4') {
                string C = "";
                C += memory[counter(PC + 1)][1];
                MoveRegisterToRegister(memory[counter(PC + 1)][0] - '0', hexToDec(C));
            } else if (memory[hxPC][0] == '5') {
                AddRegistersTwoComplement(memory[hxPC][1] - '0', memory[counter(PC + 1)][0], memory[counter(PC + 1)][1]);
            } else if (memory[hxPC][0] == 'B' || memory[hxPC][0] == 'b') {
                int check = PC;
                string pattern = memory[counter(PC + 1)];
                JumpIfEqual(memory[hxPC][1] - '0', pattern);
                if (check != PC) {
                    PC -= 2;
                }
            } else if (memory[hxPC][0] == 'C' || memory[hxPC][0] == 'c') {
                Display();
                PC = -1;
                return;  // Set PC to -1 to indicate termination
            } else {
                PC = -1;
            }
            PC += 2;
        }
        Display();
    }

    // Run the machine step by step, executing instructions
    void RunSBS() {
        if (PC == -1) {
            return;
        }
        string hxPC = counter(PC);
        if (memory[hxPC][0] == '1') {
            string pattern = memory[counter(PC + 1)];
            LoadRegisterFromMemory(memory[hxPC][1] - '0', pattern);
        } else if (memory[hxPC][0] == '2') {
            string pattern = memory[counter(PC + 1)];
            LoadRegisterWithPattern(memory[hxPC][1] - '0', pattern);
        } else if (memory[hxPC][0] == '3') {
            string pattern = memory[counter(PC + 1)];
            StoreRegisterToMemory(memory[hxPC][1] - '0', pattern);
        } else if (memory[hxPC][0] == '4') {
            string C = "";
            C += memory[counter(PC + 1)][1];
            MoveRegisterToRegister(memory[counter(PC + 1)][0] - '0', hexToDec(C));
        } else if (memory[hxPC][0] == '5') {
            AddRegistersTwoComplement(memory[hxPC][1] - '0', memory[counter(PC + 1)][0], memory[counter(PC + 1)][1]);
        } else if (memory[hxPC][0] == 'B' || memory[hxPC][0] == 'b') {
            int check = PC;
            string pattern = memory[counter(PC + 1)];
            JumpIfEqual(memory[hxPC][1] - '0', pattern);
            if (check != PC) {
                PC -= 2;
            }
        } else if (memory[hxPC][0] == 'C' || memory[hxPC][0] == 'c') {
            Display();
            PC = -1;
            return;  // Set PC to -1 to indicate termination
        } else {
            PC = -1;
        }
        PC += 2;
        Display();
        DisplayMemory();
    }

    // Display the current machine state, program counter, instruction register, and registers
    void Display() {
        string hxPC = counter(PC);
        cout << "Machine State:" << endl;
        cout << "hxPC: " << hxPC << endl;
        cout << "IR: " << memory[hxPC] << memory[counter(PC + 1)] << endl;
        cout << "Registers: \n";
        DisplayRegisters();
    }

    // Display the contents of all registers
    void DisplayRegisters() {
        for (int i = 0; i < 16; ++i) {
            cout << "R" << i << " : " << Registers.DisplayRegister(i) << endl;
        }
    }

    // Reset all registers to '00'
    void ResetRegister() {
        for (int i = 0; i < 16; ++i) {
            Registers.Clear(i);
        }
    }

private:
    // Load the value from memory into a register
    void LoadRegisterFromMemory(int registerIndex, string memoryAddress) {
        Registers.setRegister(registerIndex, memory[memoryAddress]);
    }

    // Load a specific pattern into a register
    void LoadRegisterWithPattern(int registerIndex, string pattern) {
        Registers.setRegister(registerIndex, pattern);
    }

    // Store the value from a register into memory
    void StoreRegisterToMemory(int registerIndex, string memoryAddress) {
        if (memoryAddress == "00") {
            cout << "Value of register " << registerIndex << " : " << Registers.DisplayRegister(registerIndex) << "\n\n";
        } else {
            memory[memoryAddress] = Registers.DisplayRegister(registerIndex);
        }
    }

    // Move the value from one register to another
    void MoveRegisterToRegister(int sourceIndex, int destinationIndex) {
        Registers.setRegister(destinationIndex, Registers.DisplayRegister(sourceIndex));
    }

    // Add two registers using two's complement representation
    void AddRegistersTwoComplement(int resultIndex, char operandIndex1, char operandIndex2) {
        // Get the two operands from registers
        string C1 = "";
        C1 += operandIndex1;
        string C2 = "";
        C2 += operandIndex2;
        string operand1 = Registers.DisplayRegister(hexToDec(C1));
        string operand2 = Registers.DisplayRegister(hexToDec(C2));

        // Perform addition of two's complement
        int result = hexToDec(operand1) + hexToDec(operand2);

        // Handle overflow (if the result is larger than 255 or smaller than 0)
        if (result > 255 || result < 0) {
            // Handle overflow as needed for your application
            cerr << "Overflow occurred during addition." << endl;
            // You might want to set flags or take other actions based on your application's requirements
            // For simplicity, let's set the result to 0
            result = 0;
        }

        // Store the result in the specified register
        Registers.setRegister(resultIndex, decToHex(result));
    }

    // Jump to a specific memory address if the contents of a register are equal to zero
    void JumpIfEqual(int registerIndex, string memoryAddress) {
        if (Registers.DisplayRegister(registerIndex) == Registers.DisplayRegister(0)) {
            PC = hexToDec(memoryAddress);
        }
    }

    // Set the Program Counter to -1 to halt execution
    void HaltExecution() {
        PC = -1;
    }

    // Convert hexadecimal string to decimal integer
    int hexToDec(const string& hexStr) {
        int decimalValue;
        stringstream ss;
        ss << hex << hexStr;  // Set the stringstream to interpret the input as hexadecimal
        ss >> decimalValue;   // Read the hexadecimal string as an integer in decimal
        return decimalValue;
    }

    // Convert decimal integer to a two-digit hexadecimal string
    string decToHex(int decimalValue) {
        stringstream ss;
        ss << hex << uppercase << setw(2) << setfill('0') << decimalValue;
        return ss.str();
    }

    // Friend function declaration for the Menu function
    friend void Menu(machine& M);

    // Display the contents of memory (address: instruction)
    void DisplayMemory() {
        cout << "\nAddress : Instruction\n";
        for (const auto& entry : memory) {
            cout << entry.first << ": " << entry.second << "\n";
        }
        cout << endl;
    }
};

// Friend function to display the menu and interact with the machine
void Menu(machine& M) {
    int x;

    // Display menu options
    cout << "1-Run step by step\n";
    cout << "2-Run full code\n";
    cout << "3-Reset\n";

    // Get user input for menu choice
    cin >> x;

    // Execute corresponding action based on user input
    if (x == 1) {
        // Run the machine step by step
        M.RunSBS();

        // Check if the machine has terminated
        if (M.PC == -1) {
            return;
        }

        // Recursively call Menu for additional user input
        Menu(M);
    } else if (x == 2) {
        // Run the machine with full execution
        M.RunFull();
        return;  // Exit the function after full execution
    } else if (x == 3) {
        // Reset all registers and call Menu for additional user input
        M.ResetRegister();
        Menu(M);
    }
}

int main() {
    // Create a machine instance named FCB, loading instructions from the "INPUT" file
    machine FCB("INPUT");

    // Call the Menu function to interact with and control the machine
    Menu(FCB);

    return 0;
}

